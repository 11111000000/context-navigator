:PROPERTIES:
:GPTEL_MODEL: gpt-5
:GPTEL_BACKEND: AI Tunnel
:GPTEL_SYSTEM:
:GPTEL_BOUNDS: ((response (1 8977)))
:END:
Ниже — сжатый, но целостный взгляд на Context Navigator через призму диалектики: что это “в сущности”, где его противоречия, как они уже разрешены в дизайне, где остаётся трение, и какие шаги превращают его в по‑настоящему эффективный инструмент
- 1) для программирования вообще
- 2) и для программирования с ИИ.

1) Диалектический разбор: суть и эргономика

Тезис: контекст должен быть внешним, а не в голове
- Navigator материализует “контекст задачи” (файлы/буферы/выделения) в устойчивые группы на проект. Это уменьшает когнитивную нагрузку и ускоряет переключение задач.

Антитезис: программирование — динамика, контекст постоянно “течёт”
- Файлы появляются/исчезают, задача дробится, обсуждение с ИИ вносит новые точки внимания.

Синтез (реализовано):
- Группы + async‑загрузка + авто‑проект + Undo/Redo по группе → контекст остаётся движущимся, но зафиксированным в управляемых “срезах”.
- “Universal Add”, add‑by‑mask, add‑from‑text, dired‑aware → дешёвое, массовое пополнение контекста в один ход.
- Оценка затрат (Stats: байты/токены) → обратная связь по объёму.
- Односторонняя интеграция с GPTel → Navigator остаётся источником истины, chat — потребителем контекста.

Тезис: минимализм интерфейса
- Один буфер/сайдбар, компактная header‑line, локальные хоткеи, транзиент.

Антитезис: мощь требует управления сложностью (иконки, индикаторы, счётчики, фильтры)
- Много настроек может пугать.

Синтез (реализовано):
- “Автоматы по умолчанию” и выключатели трения:
  - sticky auto‑project с троттлингом,
  - индикаторы GPTel по снимку ключей,
  - counters с TTL/soft‑cap,
  - icons/remote режимы,
  - защита раскладки окон,
  - помощь “?” и транзиент.

Точки эргономического трения (и уже имеющиеся/возможные смягчения)
- Односторонность GPTel: нельзя “втянуть” контекст назад.
  - Смягчение уже есть: Add from text — можно выделить участок чата GPTel и извлечь упомянутые пути, добавив их в группу. Практически это аналог “pull”, но осознанный и безопасный.
- Токенный бюджет: легко “перекормить” LLM.
  - Есть Stats и Occam‑фильтр (R) с предварительным обзором, быстрый Undo/Redo.
- Удалённые пути/TRAMP: риск латентности и подвисаний.
  - “lazy/off” режимы, подтверждения, запрет масок на TRAMP по умолчанию.
- Переключения проектов, когда открыт сайдбар:
  - sticky‑политика + throttle + приоритет “настоящего рабочего окна” уже реализованы.

Вывод по сути
- Context Navigator — это дисциплина “инженерии контекста”: превращать хрупкий ментальный контекст в явные, быстро переключаемые, измеряемые и пригодные к взаимодействию с ИИ “срезы” проекта. С точки зрения UX — он уже минималистичен там, где это важно, и экспрессивен там, где важно управление объёмом.

2) Как сделать его реально эффективным для программирования вообще

Базовая настройка (один раз)
- Привяжите глобальную клавишу к транзиенту: context-navigator-global-key = "C-c n".
- Включите автозагрузку и автосохранение: context-navigator-autoload=t, context-navigator-autosave=t.
- Если GUI: context-navigator-controls-style='icons, context-navigator-render-indicator-style='icons.
- Производительность:
  - context-navigator-openable-count-ttl ~0.3
  - context-navigator-openable-soft-cap ~120
  - context-navigator-openable-remote-mode='lazy
  - context-navigator-protect-sidebar-windows=t
- Отрисовка:
  - context-navigator-render-path-prefix-mode='short
  - context-navigator-render-show-path=t (по желанию)
- Для огромных реп: оставьте icons на remote=off и mask‑expand на remote=nil.

Ежедневные приёмы (минимум кликов/мыслей)
- Проектные “микро‑группы”: bug‑123, feature‑X, docs, release. Создавайте их “a/r/c/d” в groups view.
- Формируйте контекст за минуты:
  - Dired: пометили файлы → “a” (Universal Add).
  - Быстрые шаблоны: “f” (маска, с *), например “src/*/*.ts”.
  - Из текста: “t” в коммите/Issue/PR/чат‑вставке — вытянет пути.
  - Точные куски кода: выделите регион → “a” (как selection).
- Ритм “открыть/закрыть всё”:
  - Перед погружением — “O/o” (открыть фоновые буферы), прогреваются LSP/индексы.
  - После — “K” (закрыть буферы группы), чтобы не расползался рабочий сетап.
- Контроль шума:
  - Быстрое выключение отдельных элементов: SPC/t на строке.
  - Stats (“s”) → взгляд на объём/размеры; если много — отщепите в отдельную группу или выключите лишнее.
- Переключение задач без потерь: sticky‑автопроект не даст “уплыть” в глобал; groups view подсветит активную; Undo/Redo в группе спасает от неудачных чисток.
- Быстрый вход/выход:
  - “n” — показать/спрятать панель,
  - “p” в транзиенте — явно привяжите Navigator к проекту текущего буфера.

Полезные “рабочие соглашения”
- “Reference” (глобальная группа): линтеры, style‑guide, README, набор частых подсказок — всегда под рукой.
- “Review” (временная): из описания PR с “t” собирайте файлы — меньше ошибок при просмотре.
- “Investigate”: лог, config, гипотезы → всё в один снимок, Undo/Redo для черновиков.

Потенциальные микро‑улучшения (идеи для задач/скриптов на вашей стороне)
- “Add git‑changed”: команда, собирающая файлы из git diff (HEAD или staging) и добавляющая их в группу.
- “Duplicate‑to‑scratch”: быстро копировать текущую группу для эксперимента и работать там (автоматизировать вызов group‑duplicate + переключение).
- “Add from grep/consult‑ripgrep”: из результатов поиска (списка путей) — в контекст (через add‑from‑text, это уже почти готово).

3) Как сделать его по‑настоящему эффективным для программирования с ИИ

Принципиальная позиция: Navigator — источник истины, ИИ — потребитель
- Односторонний push в GPTel — осознанное решение: оно защищает от “поплывшего” контекста. Держите push→gptel включённым, а предметную область — в группах.

Практика “с нулём трения”
- Включите автопуш: [→] в header или G в транзиенте (по умолчанию можно держать ON).
- Работайте в GPTel, не отрываясь от проекта:
  - Автопроект учитывает gptel/gptel‑aibo буферы, Navigator не потеряет корень.
  - Индикаторы ●/○ рядом с элементами говорят, что реально в GPTel.
- Выжимайте контекст под бюджет:
  - Stats (с токенами) + Occam (R). Рекомендация: parse‑mode=flex, allow‑fuzzy=nil для безопасной фактуры; дешёвую модель можно поставить по умолчанию (deepseek‑chat в настройках razor).
  - Occam даёт превью, просит подтверждение и поддерживает Undo/Redo.

Сценарии высокого КПД
- “Issue‑driven chat”: создаёте группу на задачу, добавляете важные файлы и выделения, auto‑push ON. Пишите в GPTel — диалог стабильно “заземлён”.
- “Review‑assistant”: копируете текст PR/патча в Emacs → “t” (Add from text) → push → просите ИИ обзор/риски/регрессы, затем Occam для ужатия.
- “Debug‑assistant”: лог, конфиги, проблемные места как selections; auto‑push; просите ИИ сценарий воспроизведения, гипотезы и эксперимент — всё с тем же стабильным контекстом.
- “Refactor‑assistant”: соберите слой/модуль (маска + “t” из дизайн‑дока), запустите Occam, затем уточняющие вопросы — диалог остаётся на “одних и тех же страницах”.

Мини‑приём “почти pull из чата, но безопасно”
- Чтобы “перетащить” ссылки из GPTel обратно в Navigator, не делайте импорт — просто выделите кусок чата в GPTel и нажмите “t” (Add from text). Парсер вытащит пути/имена и добавит файлы. Это даёт ручную валидацию и не ломает принцип односторонности.

Токенный режим “зелёный/жёлтый/красный”
- Зелёный: Stats показывает комфортный объём — работайте.
- Жёлтый: сначала Occam для ужатия, выключите несущественные элементы (SPC).
- Красный: разделите группу на 2 (дубликат + чистка), переключайтесь по очереди.

Пара полезных настроек под ИИ‑цикл
- Если вы часто пушите на “скрытом” GPTel — оставьте context-navigator-gptel-require-visible-window=nil (по умолчанию так). Если среда тяжёлая, можно включить deferral, чтобы apply ждал видимого окна GPTel.
- Повысьте batch‑size/interval, если поток добавления крупный: context-navigator-gptel-apply-batch-size и -interval.

Идеи развития (если захочется расширить)
- Команда “Add from gptel buffer” как сахар: тонкая оболочка вокруг уже существующего add‑from‑text, ограниченная активным GPTel буфером.
- Команда “Add git‑changed” (описано выше).
- Команда “Create group from chat excerpt”: вырезка из чата → новая группа → auto‑push → эксперименты, не ломая основную задачу.

Короткий чек‑лист внедрения
- Привязать “C-c n”, включить автопроект/автосейв.
- Принять дисциплину “микро‑групп” и жест “O…K”.
- Регулярно пользоваться “t” (из текста) и “f” (маски) — это главные ускорители.
- Удерживать auto‑push ON, а объём — через Stats+Occam.
- Для чатов: вырезки из GPTel → “t” → обратно в группу (без магии и сюрпризов).

Итог
- Уже сейчас Navigator решает главное противоречие современного рабочего цикла: необходимость быстрой, дешёвой и управляемой материализации контекста для человека и LLM. Чтобы система “поехала”, нужны три привычки: (1) группы по задачам, (2) два быстрых жеста добавления (Dired/маски/из текста), (3) регулярная экономия токенов (Stats+Occam). Всё остальное — тюнинг под размер репо и вашу манеру работы.

*** 
